package dunst

import (
	"strings"
	"testing"

	"github.com/jmylchreest/tinct/internal/colour"
	plugintesting "github.com/jmylchreest/tinct/internal/plugin/output/testing"
)

// TestDunstPlugin runs all standard plugin tests using shared utilities.
func TestDunstPlugin(t *testing.T) {
	plugin := New()

	config := plugintesting.TestConfig{
		ExpectedName:       "dunst",
		ExpectedFiles:      []string{"tinct.dunstrc"},
		ExpectedBinaryName: "dunst",
	}

	plugintesting.RunAllTests(t, plugin, config)
}

// TestDunstPlugin_ContentValidation tests dunst-specific content requirements.
func TestDunstPlugin_ContentValidation(t *testing.T) {
	palette := plugintesting.CreateTestPalette(colour.ThemeDark)
	plugin := New()

	files, err := plugin.Generate(palette)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	content := string(files["tinct.dunstrc"])

	// Check for required sections
	requiredStrings := []string{
		"# Dunst colour theme generated by Tinct",
		"[urgency_low]",
		"[urgency_normal]",
		"[urgency_critical]",
		"background =",
		"foreground =",
		"frame_color =",
		"highlight =",
		"timeout =",
	}

	for _, required := range requiredStrings {
		if !strings.Contains(content, required) {
			t.Errorf("Generated content missing required string: %s", required)
		}
	}

	// Check that theme type is present
	if !strings.Contains(content, "Detected theme: dark") {
		t.Error("Generated content missing theme type")
	}
}

// TestDunstPlugin_GenerateWithLightTheme tests light theme generation.
func TestDunstPlugin_GenerateWithLightTheme(t *testing.T) {
	palette := plugintesting.CreateTestPalette(colour.ThemeLight)
	plugin := New()

	files, err := plugin.Generate(palette)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	content := string(files["tinct.dunstrc"])

	// Check that theme type is present
	if !strings.Contains(content, "Detected theme: light") {
		t.Error("Generated content missing light theme type")
	}
}

// TestDunstPlugin_CustomOutputDir tests custom output directory handling.
func TestDunstPlugin_CustomOutputDir(t *testing.T) {
	plugin := New()
	plugin.outputDir = "/custom/path"

	dir := plugin.DefaultOutputDir()
	if dir != "/custom/path" {
		t.Errorf("DefaultOutputDir() = %s, want /custom/path", dir)
	}
}

// TestDunstPlugin_GetEmbeddedTemplates tests embedded template access.
func TestDunstPlugin_GetEmbeddedTemplates(t *testing.T) {
	fs := GetEmbeddedTemplates()

	entries, err := fs.ReadDir(".")
	if err != nil {
		t.Fatalf("ReadDir() error = %v", err)
	}

	found := false
	for _, entry := range entries {
		if entry.Name() == "tinct.dunstrc.tmpl" {
			found = true
			break
		}
	}

	if !found {
		t.Error("Template file tinct.dunstrc.tmpl not found in embedded filesystem")
	}
}

// TestDunstPlugin_PrepareThemeData tests theme data preparation.
func TestDunstPlugin_PrepareThemeData(t *testing.T) {
	palette := plugintesting.CreateTestPalette(colour.ThemeDark)
	plugin := New()

	data := plugin.prepareThemeData(palette)

	// Check that PaletteHelper is created properly
	if data == nil {
		t.Fatal("prepareThemeData should return non-nil PaletteHelper")
	}

	// Check that required roles exist
	requiredRoles := []colour.ColourRole{
		colour.RoleBackground,
		colour.RoleForeground,
		colour.RoleAccent1,
		colour.RoleDanger,
		colour.RoleWarning,
		colour.RoleSuccess,
		colour.RoleInfo,
	}

	for _, role := range requiredRoles {
		if !data.Has(role) {
			t.Errorf("PaletteHelper missing required role: %s", role)
		}
	}

	// Check that theme type matches
	if data.ThemeTypeString() != "dark" {
		t.Errorf("ThemeTypeString() = %s, want dark", data.ThemeTypeString())
	}
}

// TestDunstPlugin_ColorFormatting tests that colors are formatted correctly.
func TestDunstPlugin_ColorFormatting(t *testing.T) {
	palette := plugintesting.CreateTestPalette(colour.ThemeDark)
	plugin := New()

	files, err := plugin.Generate(palette)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	content := string(files["tinct.dunstrc"])

	// Verify hex color format (#RRGGBB)
	if !strings.Contains(content, "#") {
		t.Error("Generated content should contain hex colors")
	}

	// Verify urgency_critical has timeout = 0
	urgencyCriticalSection := content[strings.Index(content, "[urgency_critical]"):]
	if !strings.Contains(urgencyCriticalSection, "timeout = 0") {
		t.Error("urgency_critical should have timeout = 0")
	}

	// Verify urgency_normal and urgency_low have timeout = 10
	urgencyNormalSection := content[strings.Index(content, "[urgency_normal]"):strings.Index(content, "[urgency_critical]")]
	if !strings.Contains(urgencyNormalSection, "timeout = 10") {
		t.Error("urgency_normal should have timeout = 10")
	}
}
