# Output Plugins

Output plugins generate configuration files from extracted colour palettes. They use Go's `text/template` package with embedded template files for easy customization.

## Architecture

### Plugin Structure

Each plugin lives in its own directory with:
- `plugin_name.go` - Plugin implementation
- `*.tmpl` - Template files (embedded with `go:embed`)
- `plugin_name_test.go` - Tests

Example structure:
```
internal/plugin/output/
‚îú‚îÄ‚îÄ plugin.go              # Base plugin interface
‚îú‚îÄ‚îÄ tailwind/
‚îÇ   ‚îú‚îÄ‚îÄ tailwind.go        # Plugin implementation
‚îÇ   ‚îú‚îÄ‚îÄ globals.css.tmpl   # CSS template
‚îÇ   ‚îú‚îÄ‚îÄ tailwind.config.js.tmpl  # Config template
‚îÇ   ‚îî‚îÄ‚îÄ tailwind_test.go   # Tests
‚îî‚îÄ‚îÄ alacritty/
    ‚îú‚îÄ‚îÄ alacritty.go
    ‚îú‚îÄ‚îÄ alacritty.toml.tmpl
    ‚îî‚îÄ‚îÄ alacritty_test.go
```

### Benefits

‚úÖ **Separation of Concerns**: Templates separate from Go code  
‚úÖ **Easy to Edit**: Modify templates without touching Go  
‚úÖ **Version Control**: Templates tracked separately  
‚úÖ **No Runtime Dependencies**: Templates embedded at compile time  
‚úÖ **User Customizable**: Can load templates from disk (future feature)  
‚úÖ **Fast Development**: New plugins = new template + small Go wrapper  

## Creating a New Plugin

### Step 1: Create Plugin Directory

```bash
mkdir internal/plugin/output/myplugin
```

### Step 2: Create Template File

`internal/plugin/output/myplugin/config.tmpl`:

```
# My App Config
# Generated by Tinct

background = "{{ .Background.Hex }}"
foreground = "{{ .Foreground.Hex }}"

{{- if .Danger }}
danger = "{{ .Danger.Hex }}"
{{- end }}

{{- if .Warning }}
warning = "{{ .Warning.Hex }}"
{{- end }}

{{- if .Success }}
success = "{{ .Success.Hex }}"
{{- end }}
```

### Step 3: Create Plugin Implementation

`internal/plugin/output/myplugin/myplugin.go`:

```go
package myplugin

import (
    "bytes"
    "embed"
    "fmt"
    "text/template"

    "github.com/jmylchreest/tinct/internal/colour"
)

//go:embed *.tmpl
var templates embed.FS

type Plugin struct{}

func New() *Plugin {
    return &Plugin{}
}

func (p *Plugin) Name() string {
    return "myplugin"
}

func (p *Plugin) Description() string {
    return "Generate MyApp configuration"
}

func (p *Plugin) FileExtension() string {
    return "conf"
}

func (p *Plugin) DefaultPath() string {
    return "~/.config/myapp/config.conf"
}

func (p *Plugin) Generate(palette *colour.CategorisedPalette) ([]byte, error) {
    if palette == nil {
        return nil, fmt.Errorf("palette cannot be nil")
    }

    // Load template
    tmplContent, err := templates.ReadFile("config.tmpl")
    if err != nil {
        return nil, fmt.Errorf("failed to read template: %w", err)
    }

    // Parse template
    tmpl, err := template.New("config").Parse(string(tmplContent))
    if err != nil {
        return nil, fmt.Errorf("failed to parse template: %w", err)
    }

    // Prepare data
    data := prepareData(palette)

    // Execute template
    var buf bytes.Buffer
    if err := tmpl.Execute(&buf, data); err != nil {
        return nil, fmt.Errorf("failed to execute template: %w", err)
    }

    return buf.Bytes(), nil
}

// TemplateData holds data for the template
type TemplateData struct {
    Background colour.CategorisedColour
    Foreground colour.CategorisedColour
    Danger     *colour.CategorisedColour
    Warning    *colour.CategorisedColour
    Success    *colour.CategorisedColour
}

func prepareData(palette *colour.CategorisedPalette) TemplateData {
    data := TemplateData{}

    if bg, ok := palette.Get(colour.RoleBackground); ok {
        data.Background = bg
    }
    if fg, ok := palette.Get(colour.RoleForeground); ok {
        data.Foreground = fg
    }
    if danger, ok := palette.Get(colour.RoleDanger); ok {
        data.Danger = &danger
    }
    if warning, ok := palette.Get(colour.RoleWarning); ok {
        data.Warning = &warning
    }
    if success, ok := palette.Get(colour.RoleSuccess); ok {
        data.Success = &success
    }

    return data
}
```

### Step 4: Create Tests

`internal/plugin/output/myplugin/myplugin_test.go`:

```go
package myplugin

import (
    "image/color"
    "strings"
    "testing"

    "github.com/jmylchreest/tinct/internal/colour"
)

func TestPlugin_Generate(t *testing.T) {
    colors := []color.Color{
        color.RGBA{R: 20, G: 20, B: 30, A: 255},
        color.RGBA{R: 230, G: 230, B: 240, A: 255},
        color.RGBA{R: 229, G: 76, B: 76, A: 255},
    }

    palette := &colour.Palette{Colors: colors}
    config := colour.DefaultCategorisationConfig()
    categorised := colour.Categorise(palette, config)

    plugin := New()
    output, err := plugin.Generate(categorised)
    if err != nil {
        t.Fatalf("Generate() error = %v", err)
    }

    outputStr := string(output)

    // Verify output contains expected keys
    if !strings.Contains(outputStr, "background =") {
        t.Error("Output missing background")
    }
    if !strings.Contains(outputStr, "foreground =") {
        t.Error("Output missing foreground")
    }
}
```

### Step 5: Run Tests

```bash
go test ./internal/plugin/output/myplugin/...
```

## Template Functions

### Built-in Functions

Go templates provide several built-in functions:

- `{{ .Field }}` - Access field
- `{{ if .Field }}...{{ end }}` - Conditional
- `{{ range .List }}...{{ end }}` - Loop
- `{{ printf "%s" .Value }}` - Format string
- `{{- }}` - Trim whitespace

### Custom Functions

Add custom functions with `template.FuncMap`:

```go
func templateFuncs() template.FuncMap {
    return template.FuncMap{
        "toRGB": func(cc colour.CategorisedColour) string {
            return fmt.Sprintf("rgb(%d, %d, %d)", 
                cc.RGB.R, cc.RGB.G, cc.RGB.B)
        },
        "toHSL": func(cc colour.CategorisedColour) string {
            return fmt.Sprintf("%.1f %.1f%% %.1f%%",
                cc.Hue, cc.Saturation*100, cc.Luminance*100)
        },
        "opacity": func(hex string, alpha float64) string {
            return fmt.Sprintf("%s%02x", hex, int(alpha*255))
        },
    }
}

// Use in template:
tmpl, err := template.New("config").Funcs(templateFuncs()).Parse(tmplContent)
```

### Available Color Data

In templates, you have access to `CategorisedColour` struct:

```go
type CategorisedColour struct {
    Role       ColourRole  // "background", "danger", etc.
    Hex        string      // "#e54c4c"
    RGB        RGB         // {R: 229, G: 76, B: 76}
    Luminance  float64     // 0.22 (WCAG luminance)
    IsLight    bool        // false
    Hue        float64     // 0.0 (0-360)
    Saturation float64     // 0.75 (0-1)
}
```

## Template Examples

### Simple Key-Value Config

```
background = "{{ .Background.Hex }}"
foreground = "{{ .Foreground.Hex }}"
accent = "{{ .Primary.Hex }}"
```

### JSON Output

```json
{
  "colors": {
    "background": "{{ .Background.Hex }}",
    "foreground": "{{ .Foreground.Hex }}",
{{- if .Danger }}
    "danger": "{{ .Danger.Hex }}",
{{- end }}
{{- if .Warning }}
    "warning": "{{ .Warning.Hex }}",
{{- end }}
    "accents": [
{{- range $i, $accent := .Accents }}
      "{{ $accent.Hex }}"{{ if ne $i $.AccentsLast }},{{ end }}
{{- end }}
    ]
  }
}
```

### TOML Config

```toml
[colors]
background = "{{ .Background.Hex }}"
foreground = "{{ .Foreground.Hex }}"

[colors.semantic]
danger = "{{ .Danger.Hex }}"
warning = "{{ .Warning.Hex }}"
success = "{{ .Success.Hex }}"
info = "{{ .Info.Hex }}"

[colors.accents]
{{- range $i, $accent := .Accents }}
accent{{ add $i 1 }} = "{{ $accent.Hex }}"
{{- end }}
```

### CSS Variables

```css
:root {
  --color-background: {{ .Background.RGB.R }}, {{ .Background.RGB.G }}, {{ .Background.RGB.B }};
  --color-foreground: {{ .Foreground.RGB.R }}, {{ .Foreground.RGB.G }}, {{ .Foreground.RGB.B }};
  --color-danger: {{ .Danger.RGB.R }}, {{ .Danger.RGB.G }}, {{ .Danger.RGB.B }};
}
```

### Shell Script

```bash
#!/bin/bash
# Generated by Tinct

export COLOR_BACKGROUND="{{ .Background.Hex }}"
export COLOR_FOREGROUND="{{ .Foreground.Hex }}"
export COLOR_DANGER="{{ .Danger.Hex }}"
export COLOR_WARNING="{{ .Warning.Hex }}"
export COLOR_SUCCESS="{{ .Success.Hex }}"
```

## Best Practices

### 1. Handle Missing Colors Gracefully

```go
{{- if .Danger }}
danger = "{{ .Danger.Hex }}"
{{- else }}
danger = "#ff0000"  # fallback
{{- end }}
```

### 2. Use Semantic Color Roles

Prefer semantic roles over generic colors:
- ‚úÖ `{{ .Danger.Hex }}` - Clear purpose
- ‚ùå `{{ .Red.Hex }}` - Ambiguous

### 3. Provide Sensible Defaults

Always set default values in `prepareData()`:

```go
func prepareData(palette *colour.CategorisedPalette) TemplateData {
    data := TemplateData{
        Background: getOrDefault(palette, colour.RoleBackground, "#000000"),
        Foreground: getOrDefault(palette, colour.RoleForeground, "#ffffff"),
    }
    return data
}
```

### 4. Add Comments to Generated Files

```
# Generated by Tinct {{ .Version }}
# Source: {{ .SourceImage }}
# Theme: {{ .ThemeType }}
# Generated at: {{ .Timestamp }}
```

### 5. Test Template Output

Always verify generated output is valid:

```go
func TestValidOutput(t *testing.T) {
    output, _ := plugin.Generate(palette)
    
    // Parse as TOML/JSON/YAML to verify syntax
    var config Config
    if err := toml.Unmarshal(output, &config); err != nil {
        t.Errorf("Invalid TOML output: %v", err)
    }
}
```

## Plugin Interface

All output plugins must implement:

```go
type Plugin interface {
    Name() string           // Plugin identifier
    Description() string    // Human-readable description
    FileExtension() string  // File extension (without dot)
    DefaultPath() string    // Default output path
    Generate(*colour.CategorisedPalette) ([]byte, error)
}
```

## Registry

Register plugins with the global registry:

```go
import "github.com/jmylchreest/tinct/internal/plugin/output"

func init() {
    registry := output.NewRegistry()
    registry.Register(myplugin.New())
}
```

## Future Enhancements

- [ ] Load templates from user config directory
- [ ] Template hot-reloading for development
- [ ] Template validation before generation
- [ ] Multiple format support per plugin
- [ ] Template inheritance/composition
- [ ] Sprig template functions integration

## Examples

See existing plugins for reference:
- `tailwind/` - CSS variables with HSL format
- More coming soon!

## Contributing

When adding a new plugin:

1. Create directory: `internal/plugin/output/yourplugin/`
2. Add template file: `yourplugin.tmpl`
3. Implement plugin: `yourplugin.go`
4. Add tests: `yourplugin_test.go`
5. Update this README with your plugin
6. Submit PR with example output

---

**Made with üé® and Go 1.25+**