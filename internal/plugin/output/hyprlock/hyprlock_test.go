package hyprlock

import (
	"strings"
	"testing"

	"github.com/jmylchreest/tinct/internal/colour"
	plugintesting "github.com/jmylchreest/tinct/internal/plugin/output/testing"
)

// TestHyprlockPlugin runs all standard plugin tests using shared utilities.
func TestHyprlockPlugin(t *testing.T) {
	plugin := New()

	// Run basic tests (Name, Description, Validate)
	t.Run("Name", func(t *testing.T) {
		if plugin.Name() != "hyprlock" {
			t.Errorf("Name() = %s, want hyprlock", plugin.Name())
		}
	})

	t.Run("Description", func(t *testing.T) {
		if plugin.Description() == "" {
			t.Error("Description() should not be empty")
		}
	})

	t.Run("DefaultOutputDir", func(t *testing.T) {
		dir := plugin.DefaultOutputDir()
		if dir == "" {
			t.Error("DefaultOutputDir() should not be empty")
		}
		// Hyprlock uses .config/hypr which contains "hypr" not "hyprlock"
		if !strings.Contains(dir, "hypr") {
			t.Errorf("DefaultOutputDir() = %s, should contain 'hypr'", dir)
		}
	})

	config := plugintesting.TestConfig{
		ExpectedName:       "hyprlock",
		ExpectedFiles:      []string{"tinct-hyprlock.conf"},
		ExpectedBinaryName: "hyprlock",
	}

	// Run generation and other tests
	plugintesting.TestGeneration(t, plugin, config.ExpectedFiles)
	plugintesting.TestPreExecuteHook(t, plugin, config.ExpectedBinaryName)
	plugintesting.TestFlags(t, plugin, "hyprlock")
}

// TestHyprlockPlugin_ContentValidation tests hyprlock-specific content requirements.
func TestHyprlockPlugin_ContentValidation(t *testing.T) {
	palette := plugintesting.CreateTestPalette(colour.ThemeDark)
	plugin := New()

	files, err := plugin.Generate(palette)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	content := string(files["tinct-hyprlock.conf"])

	// Check for required sections
	requiredStrings := []string{
		"# Hyprlock colour theme generated by Tinct",
		"$tinct_background",
		"$tinct_foreground",
		"$tinct_accent1",
		"rgb(",
	}

	for _, required := range requiredStrings {
		if !strings.Contains(content, required) {
			t.Errorf("Generated content missing required string: %s", required)
		}
	}

	// Check that theme type is present
	if !strings.Contains(content, "Detected theme: dark") {
		t.Error("Generated content missing theme type")
	}
}

// TestHyprlockPlugin_GenerateWithLightTheme tests light theme generation.
func TestHyprlockPlugin_GenerateWithLightTheme(t *testing.T) {
	palette := plugintesting.CreateTestPalette(colour.ThemeLight)
	plugin := New()

	files, err := plugin.Generate(palette)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	content := string(files["tinct-hyprlock.conf"])

	// Check that theme type is present
	if !strings.Contains(content, "Detected theme: light") {
		t.Error("Generated content missing light theme type")
	}
}

// TestHyprlockPlugin_CustomOutputDir tests custom output directory handling.
func TestHyprlockPlugin_CustomOutputDir(t *testing.T) {
	plugin := New()
	plugin.outputDir = "/custom/path"

	dir := plugin.DefaultOutputDir()
	if dir != "/custom/path" {
		t.Errorf("DefaultOutputDir() = %s, want /custom/path", dir)
	}
}

// TestHyprlockPlugin_GetEmbeddedTemplates tests embedded template access.
func TestHyprlockPlugin_GetEmbeddedTemplates(t *testing.T) {
	fs := GetEmbeddedTemplates()

	entries, err := fs.ReadDir(".")
	if err != nil {
		t.Fatalf("ReadDir() error = %v", err)
	}

	found := false
	for _, entry := range entries {
		if entry.Name() == "tinct.conf.tmpl" {
			found = true
			break
		}
	}

	if !found {
		t.Error("Template file tinct.conf.tmpl not found in embedded filesystem")
	}
}

// TestHyprlockPlugin_PrepareThemeData tests theme data preparation.
func TestHyprlockPlugin_PrepareThemeData(t *testing.T) {
	palette := plugintesting.CreateTestPalette(colour.ThemeDark)
	plugin := New()

	data := plugin.prepareThemeData(palette)

	// Check that PaletteHelper is created properly
	if data == nil {
		t.Fatal("prepareThemeData should return non-nil PaletteHelper")
	}

	// Check that required roles exist
	requiredRoles := []colour.ColourRole{
		colour.RoleBackground,
		colour.RoleForeground,
		colour.RoleAccent1,
	}

	for _, role := range requiredRoles {
		if !data.Has(role) {
			t.Errorf("PaletteHelper missing required role: %s", role)
		}
	}

	// Check that theme type matches
	if data.ThemeTypeString() != "dark" {
		t.Errorf("ThemeTypeString() = %s, want dark", data.ThemeTypeString())
	}
}
