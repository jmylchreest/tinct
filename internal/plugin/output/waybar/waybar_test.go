package waybar

import (
	"image/color"
	"strings"
	"testing"

	"github.com/jmylchreest/tinct/internal/colour"
)

func TestPlugin_Name(t *testing.T) {
	plugin := New()
	if got := plugin.Name(); got != "waybar" {
		t.Errorf("Name() = %v, want %v", got, "waybar")
	}
}

func TestPlugin_Description(t *testing.T) {
	plugin := New()
	if got := plugin.Description(); got == "" {
		t.Error("Description() returned empty string")
	}
}

func TestPlugin_DefaultOutputDir(t *testing.T) {
	plugin := New()
	dir := plugin.DefaultOutputDir()
	if dir == "" {
		t.Error("DefaultOutputDir() returned empty string")
	}
	if !strings.Contains(dir, "waybar") {
		t.Errorf("DefaultOutputDir() = %v, should contain 'waybar'", dir)
	}
}

func TestPlugin_Generate(t *testing.T) {
	colors := []color.Color{
		color.RGBA{R: 26, G: 27, B: 38, A: 255},    // Dark background
		color.RGBA{R: 192, G: 202, B: 245, A: 255}, // Light foreground
		color.RGBA{R: 137, G: 180, B: 250, A: 255}, // Blue accent
		color.RGBA{R: 229, G: 76, B: 76, A: 255},   // Red danger
		color.RGBA{R: 255, G: 158, B: 100, A: 255}, // Orange warning
		color.RGBA{R: 158, G: 206, B: 106, A: 255}, // Green success
	}

	palette := &colour.Palette{Colors: colors}
	config := colour.DefaultCategorisationConfig()
	categorised := colour.Categorise(palette, config)

	plugin := New()
	files, err := plugin.Generate(categorised)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	// Should generate at least the colors file
	if len(files) == 0 {
		t.Fatal("Generate() returned no files")
	}

	// Check that tinct-colours.css is present
	colorsCSS, ok := files["tinct-colours.css"]
	if !ok {
		t.Fatal("Generate() did not return tinct-colours.css")
	}

	colorsStr := string(colorsCSS)

	// Verify it's CSS with @define-color
	if !strings.Contains(colorsStr, "@define-color") {
		t.Error("tinct-colours.css should contain @define-color declarations")
	}

	// Verify it contains expected color variables
	expectedVars := []string{
		"@define-color background",
		"@define-color foreground",
	}
	for _, expected := range expectedVars {
		if !strings.Contains(colorsStr, expected) {
			t.Errorf("tinct-colours.css should contain %q", expected)
		}
	}

	// Verify hex color format
	if !strings.Contains(colorsStr, "#") {
		t.Error("tinct-colours.css should contain hex colors")
	}

	// Check that tinct.css stub is generated by default
	stubCSS, ok := files["tinct.css"]
	if !ok {
		t.Fatal("Generate() did not return tinct.css stub")
	}

	stubStr := string(stubCSS)

	// Verify it imports the colors file
	if !strings.Contains(stubStr, "@import") {
		t.Error("tinct.css should import tinct-colours.css")
	}
	if !strings.Contains(stubStr, "tinct-colours.css") {
		t.Error("tinct.css should reference tinct-colours.css")
	}

	// Verify it uses color variables
	if !strings.Contains(stubStr, "@background") || !strings.Contains(stubStr, "@foreground") {
		t.Error("tinct.css should use color variables")
	}
}

func TestPlugin_GenerateWithoutStub(t *testing.T) {
	colors := []color.Color{
		color.RGBA{R: 26, G: 27, B: 38, A: 255},
		color.RGBA{R: 192, G: 202, B: 245, A: 255},
	}

	palette := &colour.Palette{Colors: colors}
	config := colour.DefaultCategorisationConfig()
	categorised := colour.Categorise(palette, config)

	plugin := New()
	plugin.generateStub = false

	files, err := plugin.Generate(categorised)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	// Should only have colors file
	if _, ok := files["tinct-colours.css"]; !ok {
		t.Error("Generate() should still return tinct-colours.css")
	}

	// Should not have stub file
	if _, ok := files["tinct.css"]; ok {
		t.Error("Generate() should not return tinct.css when generateStub is false")
	}
}

func TestPlugin_GenerateNilPalette(t *testing.T) {
	plugin := New()
	_, err := plugin.Generate(nil)
	if err == nil {
		t.Error("Generate() with nil palette should return error")
	}
}

func TestPlugin_Validate(t *testing.T) {
	plugin := New()
	if err := plugin.Validate(); err != nil {
		t.Errorf("Validate() error = %v", err)
	}
}

func TestPlugin_SetVerbose(t *testing.T) {
	plugin := New()
	plugin.SetVerbose(true)
	if !plugin.verbose {
		t.Error("SetVerbose(true) did not set verbose flag")
	}

	plugin.SetVerbose(false)
	if plugin.verbose {
		t.Error("SetVerbose(false) did not unset verbose flag")
	}
}

func TestPrepareColorsData(t *testing.T) {
	colors := []color.Color{
		color.RGBA{R: 26, G: 27, B: 38, A: 255},
		color.RGBA{R: 192, G: 202, B: 245, A: 255},
		color.RGBA{R: 137, G: 180, B: 250, A: 255},
		color.RGBA{R: 229, G: 76, B: 76, A: 255},
	}

	palette := &colour.Palette{Colors: colors}
	config := colour.DefaultCategorisationConfig()
	categorised := colour.Categorise(palette, config)

	plugin := New()
	data := plugin.prepareColorsData(categorised)

	// Should have theme type
	if data.SourceTheme == "" {
		t.Error("prepareColorsData() should set SourceTheme")
	}

	// Should have colors
	if len(data.Colors) == 0 {
		t.Error("prepareColorsData() should return colors")
	}

	// Check that colors have required fields
	for i, col := range data.Colors {
		if col.Name == "" {
			t.Errorf("Color %d should have a name", i)
		}
		if col.Hex == "" {
			t.Errorf("Color %d should have a hex value", i)
		}
		if !strings.HasPrefix(col.Hex, "#") {
			t.Errorf("Color %d hex value should start with #, got %q", i, col.Hex)
		}
	}

	// Verify semantic role mapping
	foundBackground := false
	foundForeground := false
	for _, col := range data.Colors {
		if col.Name == "background" {
			foundBackground = true
		}
		if col.Name == "foreground" {
			foundForeground = true
		}
	}

	if !foundBackground {
		t.Error("prepareColorsData() should include background color")
	}
	if !foundForeground {
		t.Error("prepareColorsData() should include foreground color")
	}
}

func TestColorDefinition(t *testing.T) {
	def := ColorDefinition{
		Name: "test-color",
		Hex:  "#1a1b26",
	}

	if def.Name != "test-color" {
		t.Errorf("ColorDefinition.Name = %v, want %v", def.Name, "test-color")
	}
	if def.Hex != "#1a1b26" {
		t.Errorf("ColorDefinition.Hex = %v, want %v", def.Hex, "#1a1b26")
	}
}
