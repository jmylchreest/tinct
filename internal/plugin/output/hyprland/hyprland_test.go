package hyprland

import (
	"path/filepath"
	"strings"
	"testing"

	"github.com/jmylchreest/tinct/internal/colour"
	plugintesting "github.com/jmylchreest/tinct/internal/plugin/output/testing"
)

// TestHyprlandPlugin runs all standard plugin tests using shared utilities.
func TestHyprlandPlugin(t *testing.T) {
	plugin := New()

	// Run basic tests (Name, Description, Validate).
	t.Run("Name", func(t *testing.T) {
		if plugin.Name() != "hyprland" {
			t.Errorf("Name() = %s, want hyprland", plugin.Name())
		}
	})

	t.Run("Description", func(t *testing.T) {
		if plugin.Description() == "" {
			t.Error("Description() should not be empty")
		}
	})

	t.Run("DefaultOutputDir", func(t *testing.T) {
		dir := plugin.DefaultOutputDir()
		if dir == "" {
			t.Error("DefaultOutputDir() should not be empty")
		}
		// Hyprland uses .config/hypr which contains "hypr" not "hyprland".
		if !strings.Contains(dir, "hypr") {
			t.Errorf("DefaultOutputDir() = %s, should contain 'hypr'", dir)
		}
	})

	config := plugintesting.TestConfig{
		ExpectedName:       "hyprland",
		ExpectedFiles:      []string{"tinct-colours.conf", "tinct.conf"},
		ExpectedBinaryName: "Hyprland",
	}

	// Run generation and other tests.
	plugintesting.TestGeneration(t, plugin, config.ExpectedFiles)
	plugintesting.TestPreExecuteHook(t, plugin, config.ExpectedBinaryName)
	plugintesting.TestFlags(t, plugin, "hyprland")
}

// TestHyprlandPlugin_ContentValidation tests hyprland-specific content requirements.
func TestHyprlandPlugin_ContentValidation(t *testing.T) {
	palette := plugintesting.CreateTestPalette(colour.ThemeDark)
	plugin := New()

	themeData := colour.NewThemeData(palette, "", "")
	files, err := plugin.Generate(themeData)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	content := string(files["tinct-colours.conf"])

	// Check for required sections.
	requiredStrings := []string{
		"# Hyprland colour variables generated by Tinct",
		"$backgroundRGB",
		"$foregroundRGB",
		"Detected theme: dark",
	}

	for _, required := range requiredStrings {
		if !strings.Contains(content, required) {
			t.Errorf("Generated content missing required string: %s", required)
		}
	}

	// Check that theme type is present.
	if !strings.Contains(content, "Detected theme: dark") {
		t.Error("Generated content missing theme type")
	}
}

// TestHyprlandPlugin_GenerateWithLightTheme tests light theme generation.
func TestHyprlandPlugin_GenerateWithLightTheme(t *testing.T) {
	palette := plugintesting.CreateTestPalette(colour.ThemeLight)
	plugin := New()

	themeData := colour.NewThemeData(palette, "", "")
	files, err := plugin.Generate(themeData)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	content := string(files["tinct-colours.conf"])

	// Check that theme type is present.
	if !strings.Contains(content, "Detected theme: light") {
		t.Error("Generated content missing light theme type")
	}
}

// TestHyprlandPlugin_GenerateWithStub tests stub file generation.
func TestHyprlandPlugin_GenerateWithStub(t *testing.T) {
	palette := plugintesting.CreateTestPalette(colour.ThemeDark)
	plugin := New()
	plugin.generateStub = true
	plugin.stubPath = "hyprland.conf"

	themeData := colour.NewThemeData(palette, "", "")
	files, err := plugin.Generate(themeData)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	// Should have both main theme and stub.
	if len(files) != 2 {
		t.Fatalf("Generate() with stub returned %d files, want 2", len(files))
	}

	if _, ok := files["tinct-colours.conf"]; !ok {
		t.Error("Generate() did not return tinct-colours.conf")
	}

	stubFile := "tinct.conf"
	if plugin.stubPath != "" {
		stubFile = filepath.Base(plugin.stubPath)
	}
	if _, ok := files[stubFile]; !ok {
		t.Errorf("Generate() did not return stub file %s", stubFile)
	}

	stubContent := string(files[stubFile])
	if !strings.Contains(stubContent, "source") {
		t.Error("Stub file should contain source directive")
	}
}

// TestHyprlandPlugin_GenerateWithoutStub tests generation without stub file.
func TestHyprlandPlugin_GenerateWithoutStub(t *testing.T) {
	palette := plugintesting.CreateTestPalette(colour.ThemeDark)
	plugin := New()
	plugin.generateStub = false

	themeData := colour.NewThemeData(palette, "", "")
	files, err := plugin.Generate(themeData)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}

	// Should only have colors file.
	if len(files) != 1 {
		t.Fatalf("Generate() without stub returned %d files, want 1", len(files))
	}

	if _, ok := files["tinct-colours.conf"]; !ok {
		t.Error("Generate() should still return tinct-colours.conf")
	}

	// Should not have stub file.
	if _, ok := files["tinct.conf"]; ok {
		t.Error("Generate() should not return tinct.conf when generateStub is false")
	}
}

// TestHyprlandPlugin_CustomOutputDir tests custom output directory handling.
func TestHyprlandPlugin_CustomOutputDir(t *testing.T) {
	plugin := New()
	plugin.outputDir = "/custom/path"

	dir := plugin.DefaultOutputDir()
	if dir != "/custom/path" {
		t.Errorf("DefaultOutputDir() = %s, want /custom/path", dir)
	}
}

// TestHyprlandPlugin_GetEmbeddedTemplates tests embedded template access.
func TestHyprlandPlugin_GetEmbeddedTemplates(t *testing.T) {
	fs := GetEmbeddedTemplates()

	entries, err := fs.ReadDir(".")
	if err != nil {
		t.Fatalf("ReadDir() error = %v", err)
	}

	foundColors := false
	foundStub := false
	for _, entry := range entries {
		if entry.Name() == "tinct-colours.conf.tmpl" {
			foundColors = true
		}
		if entry.Name() == "tinct.conf.tmpl" {
			foundStub = true
		}
	}

	if !foundColors {
		t.Error("Template file tinct-colours.conf.tmpl not found in embedded filesystem")
	}
	if !foundStub {
		t.Error("Template file tinct.conf.tmpl not found in embedded filesystem")
	}
}
